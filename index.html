<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mecânica Respiratória — Curvas Ventilatórias (Educacional)</title>

  <meta name="description" content="App educacional: leitura de mecânica respiratória por sinais observáveis nas curvas ventilatórias. Sem loops. Sem orientação de conduta." />
  <meta name="robots" content="index,follow" />

  <style>
    :root{
      --bg:#0b1220;
      --card:#0f1b33;
      --card2:#0c1730;
      --text:#e6eefc;
      --muted:#a7b6d6;
      --line:#223457;
      --accent:#7aa2ff;
      --accent2:#47d7ac;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --radius: 14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 900px at 15% 0%, #13264f 0%, var(--bg) 55%);
      color:var(--text);
    }
    a{color:var(--accent); text-decoration:none}
    .wrap{max-width:1100px; margin:0 auto; padding:18px 14px 48px}
    header{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,18,32,.9), rgba(11,18,32,.65));
      border-bottom:1px solid rgba(34,52,87,.45);
    }
    .head{
      max-width:1100px; margin:0 auto; padding:14px 14px 10px;
      display:flex; gap:12px; align-items:flex-start; justify-content:space-between;
    }
    .title h1{margin:0; font-size:18px; letter-spacing:.2px}
    .title p{margin:4px 0 0; color:var(--muted); font-size:12.8px; line-height:1.35}
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid rgba(122,162,255,.35);
      background: rgba(122,162,255,.12);
      color: var(--text);
      padding:8px 10px; border-radius:999px;
      font-size:12.5px; white-space:nowrap;
    }
    .tabs{
      max-width:1100px; margin:0 auto; padding:0 14px 12px;
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .tab{
      border:1px solid rgba(34,52,87,.75);
      background: rgba(15,27,51,.55);
      color: var(--text);
      padding:10px 12px;
      border-radius: 999px;
      font-weight:650;
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      border-color: rgba(122,162,255,.85);
      background: rgba(122,162,255,.18);
    }

    .grid{display:grid; gap:12px}
    @media(min-width:920px){ .grid.two{grid-template-columns: 1fr 1fr} }
    .card{
      border:1px solid rgba(34,52,87,.75);
      background: linear-gradient(180deg, rgba(15,27,51,.75), rgba(12,23,48,.7));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px;
    }
    .card h2{margin:0 0 10px; font-size:14px; letter-spacing:.2px}
    .muted{color:var(--muted); font-size:12.7px; line-height:1.35}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(34,52,87,.75);
      background: rgba(255,255,255,.04);
      color: var(--muted);
      font-size:12px;
    }
    .sep{height:1px; background: rgba(34,52,87,.7); margin:12px 0}
    .btn{
      border:1px solid rgba(34,52,87,.9);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      font-size:13px;
    }
    .btn.primary{
      border-color: rgba(71,215,172,.75);
      background: rgba(71,215,172,.14);
    }
    .btn.ghost{
      border-color: rgba(122,162,255,.6);
      background: rgba(122,162,255,.10);
    }
    .btn:disabled{opacity:.45; cursor:not-allowed}
    .choices{
      display:grid; gap:8px;
      margin-top:8px;
    }
    .choice{
      display:flex; gap:10px; align-items:flex-start;
      padding:10px;
      border-radius:12px;
      border:1px solid rgba(34,52,87,.65);
      background: rgba(255,255,255,.03);
    }
    .choice input{margin-top:2px}
    .choice label{font-weight:650; font-size:13px}
    .choice small{display:block; color:var(--muted); font-size:12.2px; margin-top:2px}
    .radioRow{display:flex; gap:10px; flex-wrap:wrap}
    .radioBtn{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid rgba(34,52,87,.75);
      background: rgba(255,255,255,.03);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      user-select:none;
    }
    .radioBtn.active{
      border-color: rgba(122,162,255,.85);
      background: rgba(122,162,255,.18);
    }
    .note{
      border:1px solid rgba(255,204,102,.45);
      background: rgba(255,204,102,.08);
      color: var(--text);
      padding:10px 12px;
      border-radius: 12px;
      font-size:12.6px;
      line-height:1.35;
    }
    .danger{
      border-color: rgba(255,107,107,.45);
      background: rgba(255,107,107,.08);
    }
    .result h3{margin:0 0 8px; font-size:13.5px}
    .result .box{
      border:1px solid rgba(34,52,87,.7);
      background: rgba(0,0,0,.10);
      border-radius: 12px;
      padding:10px 12px;
      margin-top:8px;
    }
    .result ul{margin:8px 0 0 18px}
    footer{
      margin-top:18px;
      color: var(--muted);
      font-size:12.2px;
      line-height:1.35;
      border-top:1px solid rgba(34,52,87,.5);
      padding-top:14px;
    }
    details{
      border:1px solid rgba(34,52,87,.65);
      background: rgba(255,255,255,.03);
      border-radius: 12px;
      padding:10px 12px;
    }
    summary{cursor:pointer; font-weight:750}
    .kpi{
      display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;
    }
    .kpi .pill{border-color: rgba(71,215,172,.5); color: #cfeee6}
    .hidden{display:none !important}
  </style>
</head>

<body>
<header>
  <div class="head">
    <div class="title">
     <h1>Mecânica Respiratória — curvas ventilatórias</h1>
<p class="muted">Uso educacional. Não orienta condutas ou ajustes.</p>
    </div>
    <div class="badge">Educacional</div>
  </div>

  <div class="tabs">
    <div class="tab active" data-tab="ess">Aba 1 — Essencial</div>
    <div class="tab" data-tab="av">Aba 2 — Avançado</div>
    <div class="tab" data-tab="met">Aba 3 — Método e Limites</div>
  </div>
</header>

<div class="wrap">

  <!-- ====================== ABA 1 — ESSENCIAL ====================== -->
  <section id="tab_ess">
    <div class="grid two">

      <div class="card">
        <h2>1) Selecione a curva</h2>
        <div class="muted">Escolha uma curva temporal para organizar os sinais observáveis.</div>
        <div class="sep"></div>

        <div class="radioRow" id="ess_curveBtns">
          <div class="radioBtn" data-group="ess_curve" data-value="pressao">Pressão × Tempo</div>
          <div class="radioBtn" data-group="ess_curve" data-value="fluxo">Fluxo × Tempo</div>
          <div class="radioBtn" data-group="ess_curve" data-value="volume">Volume × Tempo</div>
        </div>

        <div class="sep"></div>
        <h2>2) Selecione a fase</h2>
        <div class="muted">As opções mudam conforme a curva.</div>

        <div class="radioRow" id="ess_phaseBtns"></div>

        <div class="sep"></div>
        <div id="ess_hint" class="note hidden"></div>

        <div class="row" style="margin-top:12px;">
          <button class="btn primary" id="btnEssGerar" type="button">Gerar leitura</button>
          <button class="btn" id="btnEssLimpar" type="button">Limpar</button>
        </div>
      </div>

      <div class="card">
        <h2>3) Marque os sinais observados (checkboxes)</h2>
        <div class="muted">Marque 1–3 sinais (lista curta).</div>
        <div class="sep"></div>

        <div id="ess_signalsWrap">
          <div class="note">Selecione uma curva para exibir os sinais.</div>
        </div>

        <div class="sep"></div>

        <div class="result" id="ess_result">
          <h2>Resultado</h2>
          <div class="muted">A saída aparece aqui após “Gerar leitura”.</div>

          <div class="box hidden" id="ess_outBox">
            <div class="result">
              <h3>O que se observa</h3>
              <div id="ess_obs" class="muted"></div>

              <div class="sep"></div>

              <h3>O que isso pode indicar</h3>
              <div id="ess_read" class="muted"></div>

              <div class="sep"></div>

              <h3>Limites da interpretação</h3>
              <div id="ess_limits" class="muted"></div>

              <div class="sep"></div>

              <div class="row">
                <button class="btn ghost" id="btnEssCopiar" type="button">Copiar resultado</button>
              </div>
              <div id="ess_copyMsg" class="muted" style="margin-top:8px;"></div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </section>

  <!-- ====================== ABA 2 — AVANÇADO ====================== -->
  <section id="tab_av" class="hidden">
    <div class="grid two">

      <div class="card">
        <h2>Entrada (Avançado)</h2>
        <div class="muted">Selecione curva, fase e marque múltiplos sinais. O motor aplica prioridade (final da expiração → expiração → inspiração → ciclo a ciclo) e pode gerar leitura principal + alternativas.</div>
        <div class="sep"></div>

        <div class="muted" style="margin-bottom:6px;">Curva</div>
        <div class="radioRow" id="av_curveBtns">
          <div class="radioBtn" data-group="av_curve" data-value="pressao">Pressão × Tempo</div>
          <div class="radioBtn" data-group="av_curve" data-value="fluxo">Fluxo × Tempo</div>
          <div class="radioBtn" data-group="av_curve" data-value="volume">Volume × Tempo</div>
        </div>

        <div class="sep"></div>

        <div class="muted" style="margin-bottom:6px;">Fase</div>
        <div class="radioRow" id="av_phaseBtns"></div>

        <div class="sep"></div>

        <div class="muted" style="margin-bottom:6px;">Ciclo a ciclo</div>
        <div class="radioRow" id="av_regBtns">
          <div class="radioBtn" data-group="av_reg" data-value="consistente">Consistente</div>
          <div class="radioBtn" data-group="av_reg" data-value="variavel">Variável</div>
        </div>
        <div class="muted" style="margin-top:6px;">(Opcional: use quando a variabilidade é um achado relevante.)</div>

        <div class="sep"></div>

        <div id="av_hint" class="note hidden"></div>

        <div class="row" style="margin-top:12px;">
          <button class="btn primary" id="btnAvGerar" type="button">Gerar leitura</button>
          <button class="btn" id="btnAvLimpar" type="button">Limpar</button>
        </div>
      </div>

      <div class="card">
        <h2>Sinais (Avançado)</h2>
        <div class="muted">Lista completa por curva e fase. Marque livremente.</div>
        <div class="sep"></div>

        <div id="av_signalsWrap">
          <div class="note">Selecione uma curva para exibir os sinais.</div>
        </div>

        <div class="sep"></div>

        <h2>Resultado (Avançado)</h2>
        <div class="muted">Inclui leitura principal e alternativas, quando aplicável, e bloco de limites (gerais + específicos + por tipo de leitura).</div>

        <div class="box hidden" id="av_outBox">
          <h3>O que se observa</h3>
          <div id="av_obs" class="muted"></div>

          <div class="sep"></div>

          <h3>O que isso pode indicar</h3>
          <div id="av_read" class="muted"></div>

          <div class="sep"></div>

        <h3>Limites da interpretação</h3>
<div id="av_limits_short" class="muted"></div>

<details style="margin-top:10px;">
  <summary>Ver limites completos</summary>
  <div id="av_limits" class="muted" style="margin-top:8px; white-space:pre-line;"></div>
</details>

          <div class="sep"></div>
          <div class="row">
            <button class="btn ghost" id="btnAvCopiar" type="button">Copiar resultado</button>
          </div>
          <div id="av_copyMsg" class="muted" style="margin-top:8px;"></div>
        </div>
      </div>

    </div>
  </section>

  <!-- ====================== ABA 3 — MÉTODO E LIMITES ====================== -->
  <section id="tab_met" class="hidden">
    <div class="grid">
      <div class="card">
        <h2>Como usar</h2>
        <ol class="muted" style="margin:8px 0 0 18px;">
          <li>Selecione a curva (Pressão×Tempo, Fluxo×Tempo ou Volume×Tempo).</li>
          <li>Selecione a fase e marque os sinais observados.</li>
          <li>Gere a leitura: o app entrega observação objetiva, leitura mecânica possível e limites interpretativos.</li>
        </ol>
      </div>

      <div class="card">
        <h2>Sobre o método</h2>
        <details>
          <summary>Princípios (versão sem loops)</summary>
          <div class="muted" style="margin-top:10px;">
            <ul>
              <li>Baseado em sinais observáveis em curvas temporais (pressão×tempo, fluxo×tempo, volume×tempo).</li>
              <li>Não utiliza loops (Pressão–Volume / Fluxo–Volume) nesta versão.</li>
              <li>Saída padronizada: observação objetiva → leitura mecânica possível → limites interpretativos.</li>
              <li>Sem diagnóstico, sem orientação de conduta e sem sugestão de ajustes ventilatórios.</li>
            </ul>
          </div>
        </details>

        <div class="sep"></div>

        <h2>Limites gerais (sempre aplicáveis)</h2>
        <div class="muted" id="met_limitesGerais"></div>

        <div class="sep"></div>

        <h2>O que o app não faz</h2>
        <div class="muted">
          <ul>
            <li>Não sugere ajustes de ventilador.</li>
            <li>Não define etiologia (pulmão, via aérea, parede torácica, circuito).</li>
            <li>Não estima gravidade clínica, prognóstico ou resposta terapêutica.</li>
            <li>Não substitui correlação clínica, dados numéricos, exames ou monitorização contínua.</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <h2>Autoria e uso</h2>
        <div class="muted">
          Conteúdo educacional. Autoria e estrutura do sistema protegidas. Uso comercial não autorizado.
        </div>
      </div>
    </div>
  </section>

  <footer>
  <div>Uso educacional. Não orienta condutas ou ajustes.</div>
</footer>
</div>

<script>
/* =========================
   DADOS — LIMITES
========================= */
const LIMITES_GERAIS = [
  "Não permite identificar etiologia (pulmão, via aérea, parede torácica, circuito).",
  "Não permite inferir gravidade clínica.",
  "Não distingue fenômeno transitório vs estrutural.",
  "Não correlaciona diretamente com trocas gasosas.",
  "Não substitui dados clínicos, numéricos ou exames complementares.",
  "Não orienta ajustes ventilatórios ou condutas."
];
const LIMITES_CURTOS = [
  "Leitura baseada apenas na forma da curva.",
  "Não permite diagnóstico ou definição de causa.",
  "Não orienta ajustes ou condutas."
];
const LIMITES_CURVA = {
  pressao: [
    "Não permite calcular complacência estática.",
    "Não separa componente resistivo vs elástico de forma isolada.",
    "Não permite inferir recrutamento ou sobredistensão.",
    "Não identifica nível 'adequado' de pressão.",
    "Não distingue influência de fluxo, tempo ou volume sem outras curvas."
  ],
  fluxo: [
    "Não permite diagnosticar obstrução.",
    "Não localiza segmento anatômico da resistência.",
    "Não quantifica resistência absoluta.",
    "Não infere aprisionamento aéreo isoladamente sem correlação.",
    "Não distingue demanda do sistema vs entrega do ventilador sem outras informações."
  ],
  volume: [
    "Não estima volumes pulmonares absolutos.",
    "Não identifica hiperinsuflação ou colapso por si só.",
    "Não infere segurança/eficácia de estratégia ventilatória.",
    "Não correlaciona com pressões transpulmonares.",
    "Não define adequação do volume mobilizado."
  ]
};

const LIMITES_TIPO = {
  constante_tempo: [
    "Não distingue causa pulmonar vs via aérea.",
    "Não diferencia fenômeno homogêneo vs heterogêneo.",
    "Não permite inferir reversibilidade."
  ],
  carga: [
    "Não separa causa resistiva vs elástica de forma definitiva.",
    "Não permite localizar determinantes anatômicos.",
    "Não quantifica magnitude absoluta da carga."
  ],
  estabilidade: [
    "Não garante estabilidade clínica global.",
    "Não exclui variabilidade em outros parâmetros não observados.",
    "Não substitui monitorização contínua."
  ],
  acomodacao: [
    "Não permite inferir distribuição regional.",
    "Não indica recrutamento alveolar.",
    "Não quantifica heterogeneidade."
  ]
};

/* =========================
   DADOS — SINAIS (ESSENCIAL + AVANÇADO)
   Cada sinal: id, curva, fase, label, leitura_principal, alternativas[], tipoLimite (opcional)
========================= */

const SIGNALS = [
  // PRESSÃO — Inspiração / Platô / Expiração / Ciclo a ciclo
  {id:"p_incl_igreme", curva:"pressao", fase:"inspiracao", label:"Inclinação ascendente íngreme",
    leitura:"Carga pressórica inicial aumentada / pressurização inicial predominante.",
    alt:["Componente dinâmica inicial predominante."], tipo:"carga"},
  {id:"p_incl_suave", curva:"pressao", fase:"inspiracao", label:"Inclinação ascendente suave",
    leitura:"Pressurização distribuída ao longo do tempo, com menor aceleração pressórica inicial.",
    alt:["Distribuição mais progressiva da pressão ao longo do ciclo inspiratório."], tipo:"carga"},
  {id:"p_convexa", curva:"pressao", fase:"inspiracao", label:"Curva convexa durante a inspiração",
    leitura:"Aumento progressivo da carga ao longo do enchimento (redução de acomodação ao longo da insuflação).",
    alt:["Impedância crescente ao enchimento ao longo do tempo."], tipo:"acomodacao"},
  {id:"p_concava", curva:"pressao", fase:"inspiracao", label:"Curva côncava durante a inspiração",
    leitura:"Acomodação progressiva durante a insuflação (crescimento pressórico que desacelera ao longo do tempo).",
    alt:["Maior componente inicial seguido de estabilização."], tipo:"acomodacao"},
  {id:"p_pico_precoce", curva:"pressao", fase:"inspiracao", label:"Pico de pressão precoce",
    leitura:"Carga concentrada no início da inspiração (componente dinâmica inicial predominante).",
    alt:["Pressão máxima deslocada para o início do ciclo."], tipo:"carga"},
  {id:"p_pico_tardio", curva:"pressao", fase:"inspiracao", label:"Pico de pressão tardio",
    leitura:"Carga crescente no final da inspiração (aumento progressivo de impedância ao enchimento).",
    alt:["Pressão máxima deslocada para o final do ciclo."], tipo:"carga"},

  {id:"p_plato_pres", curva:"pressao", fase:"plato", label:"Platô inspiratório presente",
    leitura:"Estabilidade pressórica em parte do ciclo (fase estática identificável).",
    alt:["Janela de estabilidade pressórica observável."], tipo:null},
  {id:"p_plato_aus", curva:"pressao", fase:"plato", label:"Platô inspiratório ausente",
    leitura:"Predomínio dinâmico durante toda a inspiração (leitura limitada de estabilidade pressórica).",
    alt:["Sem fase claramente estática na pressão."], tipo:null},
  {id:"p_plato_curto", curva:"pressao", fase:"plato", label:"Platô inspiratório curto",
    leitura:"Curta janela de estabilidade pressórica; predomínio de fase dinâmica no ciclo.",
    alt:["Estabilidade pressórica breve."], tipo:null},
  {id:"p_plato_long", curva:"pressao", fase:"plato", label:"Platô inspiratório prolongado",
    leitura:"Predomínio de fase estática (estabilidade pressórica mantida por mais tempo).",
    alt:["Estabilidade pressórica prolongada."], tipo:null},

  {id:"p_queda_rapida", curva:"pressao", fase:"expiracao", label:"Queda rápida da pressão",
    leitura:"Dissipação pressórica rápida ao término da inspiração.",
    alt:["Retorno rápido à linha de base."], tipo:"constante_tempo"},
  {id:"p_queda_lenta", curva:"pressao", fase:"expiracao", label:"Queda lenta da pressão",
    leitura:"Dissipação pressórica prolongada (constante de tempo aumentada: inferência dinâmica).",
    alt:["Liberação pressórica mais lenta durante a expiração."], tipo:"constante_tempo"},
  {id:"p_retorno_incomp", curva:"pressao", fase:"expiracao", label:"Retorno incompleto à linha de base",
    leitura:"Pressão residual ao final do ciclo (dissipação incompleta).",
    alt:["Esvaziamento passivo limitado: inferência dinâmica."], tipo:"constante_tempo"},
  {id:"p_residual_fimexp", curva:"pressao", fase:"expiracao", label:"Pressão residual ao final da expiração",
    leitura:"Pressão não totalmente dissipada ao final do ciclo.",
    alt:["Persistência de pressão residual."], tipo:"constante_tempo"},

  {id:"p_var_max", curva:"pressao", fase:"ciclo", label:"Pressão máxima variável entre ciclos",
    leitura:"Variabilidade mecânica pressórica ao longo do tempo.",
    alt:["Mudança dinâmica na carga do sistema entre ciclos."], tipo:"estabilidade"},
  {id:"p_const_max", curva:"pressao", fase:"ciclo", label:"Pressão máxima constante entre ciclos",
    leitura:"Estabilidade mecânica pressórica (comportamento reprodutível).",
    alt:["Resposta pressórica consistente."], tipo:"estabilidade"},
  {id:"p_forma_var", curva:"pressao", fase:"ciclo", label:"Forma da curva variável",
    leitura:"Mudança do padrão pressórico ao longo do tempo (instabilidade do comportamento mecânico).",
    alt:["Variação dinâmica da forma da curva."], tipo:"estabilidade"},
  {id:"p_forma_cons", curva:"pressao", fase:"ciclo", label:"Forma da curva consistente",
    leitura:"Padrão pressórico reprodutível (estabilidade do comportamento da curva).",
    alt:["Consistência morfológica ciclo a ciclo."], tipo:"estabilidade"},

  // FLUXO — Inspiração / Expiração / Final / Ciclo
  {id:"f_insp_alto", curva:"fluxo", fase:"inspiracao", label:"Fluxo inspiratório alto",
    leitura:"Entrada rápida de gás (componente dinâmica predominante na fase inicial).",
    alt:["Aceleração/entrega de fluxo elevada no início do ciclo."], tipo:"carga"},
  {id:"f_insp_baixo", curva:"fluxo", fase:"inspiracao", label:"Fluxo inspiratório baixo",
    leitura:"Entrada lenta de gás (enchimento mais gradual do sistema).",
    alt:["Menor velocidade de enchimento."], tipo:"carga"},
  {id:"f_const", curva:"fluxo", fase:"inspiracao", label:"Fluxo inspiratório constante",
    leitura:"Entrega uniforme de fluxo ao longo da inspiração.",
    alt:["Distribuição homogênea do fluxo no tempo."], tipo:null},
  {id:"f_var", curva:"fluxo", fase:"inspiracao", label:"Fluxo inspiratório variável",
    leitura:"Entrada não homogênea de fluxo (interação dinâmica variável durante a inspiração).",
    alt:["Variação intra-inspiratória do fluxo."], tipo:"estabilidade"},
  {id:"f_pico_precoce", curva:"fluxo", fase:"inspiracao", label:"Pico de fluxo inspiratório precoce",
    leitura:"Aceleração inicial predominante (fluxo máximo deslocado para o início).",
    alt:["Maior fluxo concentrado no início da inspiração."], tipo:"carga"},
  {id:"f_pico_tardio", curva:"fluxo", fase:"inspiracao", label:"Pico de fluxo inspiratório tardio",
    leitura:"Aceleração deslocada para o final (fluxo máximo mais tardio no ciclo inspiratório).",
    alt:["Entrada progressiva de gás com pico tardio."], tipo:"carga"},
  {id:"f_decl_rap", curva:"fluxo", fase:"inspiracao", label:"Declínio rápido do fluxo inspiratório",
    leitura:"Redução precoce da entrada de gás (enchimento concentrado no início).",
    alt:["Queda abrupta do fluxo durante a inspiração."], tipo:"carga"},
  {id:"f_decl_lento", curva:"fluxo", fase:"inspiracao", label:"Declínio lento do fluxo inspiratório",
    leitura:"Entrada prolongada de gás (redução gradual do fluxo).",
    alt:["Enchimento mais prolongado."], tipo:"carga"},
  {id:"f_convexa", curva:"fluxo", fase:"inspiracao", label:"Curva inspiratória convexa",
    leitura:"Aumento progressivo do fluxo ao longo da inspiração (dinâmica não uniforme).",
    alt:["Fluxo cresce ao longo do tempo inspiratório."], tipo:"acomodacao"},
  {id:"f_concava", curva:"fluxo", fase:"inspiracao", label:"Curva inspiratória côncava",
    leitura:"Fluxo maior no início com desaceleração posterior (acomodação progressiva).",
    alt:["Desaceleração do fluxo ao longo da inspiração."], tipo:"acomodacao"},
  {id:"f_irreg", curva:"fluxo", fase:"inspiracao", label:"Irregularidades no fluxo inspiratório",
    leitura:"Instabilidade do padrão inspiratório (oscilações intra-inspiratórias).",
    alt:["Variação dinâmica intra-inspiratória."], tipo:"estabilidade"},
  {id:"f_bifasico", curva:"fluxo", fase:"inspiracao", label:"Fluxo inspiratório bifásico",
    leitura:"Duas fases de entrada de fluxo (enchimento em dois tempos).",
    alt:["Distribuição não homogênea do enchimento."], tipo:"acomodacao"},

  {id:"f_exp_alto", curva:"fluxo", fase:"expiracao", label:"Fluxo expiratório alto",
    leitura:"Esvaziamento rápido (maior velocidade de saída).",
    alt:["Dissipação inicial eficiente."], tipo:"constante_tempo"},
  {id:"f_exp_baixo", curva:"fluxo", fase:"expiracao", label:"Fluxo expiratório baixo",
    leitura:"Esvaziamento lento (constante de tempo aumentada: inferência dinâmica).",
    alt:["Maior resistência dinâmica ao esvaziamento: inferência."], tipo:"constante_tempo"},
  {id:"f_exp_curta", curva:"fluxo", fase:"expiracao", label:"Expiração curta",
    leitura:"Fase expiratória comprimida (esvaziamento rápido ou potencialmente incompleto, sem conclusão isolada).",
    alt:["Menor tempo disponível para esvaziamento."], tipo:"constante_tempo"},
  {id:"f_exp_long", curva:"fluxo", fase:"expiracao", label:"Expiração prolongada",
    leitura:"Dissipação volumétrica prolongada (esvaziamento estendido).",
    alt:["Constante de tempo aumentada: inferência dinâmica."], tipo:"constante_tempo"},
  {id:"f_decl_exp_rap", curva:"fluxo", fase:"expiracao", label:"Declínio rápido do fluxo expiratório",
    leitura:"Esvaziamento inicial eficiente (queda rápida do fluxo expiratório).",
    alt:["Dissipação rápida na fase inicial."], tipo:"constante_tempo"},
  {id:"f_decl_exp_lento", curva:"fluxo", fase:"expiracao", label:"Declínio lento do fluxo expiratório",
    leitura:"Esvaziamento progressivo prolongado (queda lenta do fluxo expiratório).",
    alt:["Constante de tempo aumentada: inferência dinâmica."], tipo:"constante_tempo"},

  {id:"f_zero", curva:"fluxo", fase:"final", label:"Fluxo expiratório zera antes do próximo ciclo",
    leitura:"Esvaziamento completo antes do próximo ciclo (na curva de fluxo).",
    alt:["Retorno à linha de base dentro do tempo expiratórIo."], tipo:"constante_tempo"},
  {id:"f_nao_zero", curva:"fluxo", fase:"final", label:"Fluxo expiratório não zera",
    leitura:"Esvaziamento incompleto antes do próximo ciclo (inferência de volume residual ciclo a ciclo).",
    alt:["Acúmulo de volume residual: inferência dinâmica."], tipo:"constante_tempo"},
  {id:"f_retorno_tardio", curva:"fluxo", fase:"final", label:"Retorno tardio do fluxo à linha de base",
    leitura:"Esvaziamento prolongado com retorno tardio (constante de tempo aumentada: inferência dinâmica).",
    alt:["Dissipação lenta até a linha de base."], tipo:"constante_tempo"},

  {id:"f_perfil_cons", curva:"fluxo", fase:"ciclo", label:"Perfil de fluxo consistente entre ciclos",
    leitura:"Estabilidade do padrão de fluxo ao longo do tempo.",
    alt:["Reprodutibilidade do perfil insp/exp."], tipo:"estabilidade"},
  {id:"f_perfil_var", curva:"fluxo", fase:"ciclo", label:"Perfil de fluxo variável entre ciclos",
    leitura:"Variabilidade mecânica do padrão de fluxo ao longo do tempo.",
    alt:["Mudança dinâmica ciclo a ciclo."], tipo:"estabilidade"},
  {id:"f_assim_cons", curva:"fluxo", fase:"ciclo", label:"Assimetria inspiratória–expiratória consistente",
    leitura:"Relação fixa entre padrões inspiratório e expiratório ao longo do tempo.",
    alt:["Assimetria reprodutível entre fases."], tipo:"estabilidade"},
  {id:"f_assim_var", curva:"fluxo", fase:"ciclo", label:"Assimetria inspiratória–expiratória variável",
    leitura:"Relação instável entre fases (mudança dinâmica do padrão insp/exp).",
    alt:["Variação de assimetria ciclo a ciclo."], tipo:"estabilidade"},

  // VOLUME — Enchimento / Platô / Final / Ciclo
  {id:"v_ench_rap", curva:"volume", fase:"enchimento", label:"Enchimento rápido do volume",
    leitura:"Enchimento volumétrico rápido (taxa de aumento volumétrico elevada).",
    alt:["Volume cresce rapidamente no início do ciclo."], tipo:"carga"},
  {id:"v_ench_lento", curva:"volume", fase:"enchimento", label:"Enchimento lento do volume",
    leitura:"Enchimento volumétrico lento (taxa de aumento volumétrico reduzida).",
    alt:["Volume cresce gradualmente."], tipo:"carga"},
  {id:"v_incl_igreme", curva:"volume", fase:"enchimento", label:"Curva de volume com inclinação íngreme",
    leitura:"Alta taxa de aumento volumétrico (enchimento acelerado).",
    alt:["Crescimento volumétrico rápido."], tipo:"carga"},
  {id:"v_incl_suave", curva:"volume", fase:"enchimento", label:"Curva de volume com inclinação suave",
    leitura:"Baixa taxa de aumento volumétrico (enchimento gradual).",
    alt:["Crescimento volumétrico lento."], tipo:"carga"},

  {id:"v_plato_precoce", curva:"volume", fase:"plato", label:"Platô volumétrico precoce",
    leitura:"Volume estabiliza precocemente (enchimento concentrado no início).",
    alt:["Estabilização precoce do volume."], tipo:"acomodacao"},
  {id:"v_plato_tardio", curva:"volume", fase:"plato", label:"Platô volumétrico tardio",
    leitura:"Volume estabiliza apenas no final (enchimento progressivo).",
    alt:["Estabilização tardia do volume."], tipo:"acomodacao"},
  {id:"v_plato_aus", curva:"volume", fase:"plato", label:"Platô volumétrico ausente",
    leitura:"Ausência de fase volumétrica estável (volume varia continuamente).",
    alt:["Sem estabilização clara do volume no ciclo."], tipo:"acomodacao"},

  {id:"v_final_const", curva:"volume", fase:"final", label:"Volume final constante",
    leitura:"Estabilidade do volume mobilizado (reprodutibilidade do volume final).",
    alt:["VT/volume final consistente (descritivo)." ], tipo:"estabilidade"},
  {id:"v_final_var", curva:"volume", fase:"final", label:"Volume final variável",
    leitura:"Variabilidade do volume mobilizado ao longo do tempo.",
    alt:["Volume final não reprodutível ciclo a ciclo."], tipo:"estabilidade"},
  {id:"v_retorno_incomp", curva:"volume", fase:"final", label:"Retorno incompleto do volume à linha de base",
    leitura:"Esvaziamento incompleto com volume residual entre ciclos (inferência dinâmica).",
    alt:["Acúmulo de volume entre ciclos."], tipo:"constante_tempo"},
  {id:"v_acumulo", curva:"volume", fase:"final", label:"Volume acumulado entre ciclos",
    leitura:"Acúmulo progressivo de volume entre ciclos (retorno incompleto: inferência dinâmica).",
    alt:["Volume residual persistente."], tipo:"constante_tempo"},

  {id:"v_vt_cons", curva:"volume", fase:"ciclo", label:"Volume corrente consistente",
    leitura:"Estabilidade volumétrica (padrão reprodutível).",
    alt:["Repetibilidade do enchimento/esvaziamento."], tipo:"estabilidade"},
  {id:"v_vt_var", curva:"volume", fase:"ciclo", label:"Volume corrente variável",
    leitura:"Instabilidade volumétrica (variação ciclo a ciclo).",
    alt:["Mudança dinâmica do padrão volumétrico."], tipo:"estabilidade"},
  {id:"v_forma_cons", curva:"volume", fase:"ciclo", label:"Forma da curva volumétrica consistente",
    leitura:"Padrão volumétrico consistente ao longo do tempo.",
    alt:["Reprodutibilidade da morfologia."], tipo:"estabilidade"},
  {id:"v_forma_var", curva:"volume", fase:"ciclo", label:"Forma da curva volumétrica variável",
    leitura:"Mudança do padrão volumétrico ao longo do tempo.",
    alt:["Variação morfológica ciclo a ciclo."], tipo:"estabilidade"},
];

/* =========================
   MAPA DE FASES (por curva)
========================= */
const PHASES = {
  pressao: [
    {key:"inspiracao", label:"Inspiração"},
    {key:"plato", label:"Platô"},
    {key:"expiracao", label:"Expiração"},
    {key:"ciclo", label:"Ciclo a ciclo"},
  ],
  fluxo: [
    {key:"inspiracao", label:"Inspiração"},
    {key:"expiracao", label:"Expiração"},
    {key:"final", label:"Final da expiração"},
    {key:"ciclo", label:"Ciclo a ciclo"},
  ],
  volume: [
    {key:"enchimento", label:"Enchimento"},
    {key:"plato", label:"Platô"},
    {key:"final", label:"Final do ciclo"},
    {key:"ciclo", label:"Ciclo a ciclo"},
  ],
};

/* =========================
   ESSENCIAL — LISTA CURTA
========================= */
const ESSENTIAL_IDS = new Set([
  // Pressão essenciais
  "p_incl_igreme","p_incl_suave","p_convexa","p_concava","p_plato_pres","p_plato_aus","p_pico_precoce","p_pico_tardio",
  // Fluxo essenciais
  "f_insp_alto","f_insp_baixo","f_decl_lento","f_concava","f_exp_long","f_exp_baixo","f_nao_zero","f_perfil_var",
  // Volume essenciais
  "v_ench_rap","v_ench_lento","v_plato_precoce","v_plato_tardio","v_final_const","v_final_var","v_retorno_incomp","v_acumulo"
]);

/* =========================
   UTIL
========================= */
function qs(sel, root=document){ return root.querySelector(sel); }
function qsa(sel, root=document){ return [...root.querySelectorAll(sel)]; }

function setActiveRadio(btnsRoot, group, value){
  qsa(`.radioBtn[data-group="${group}"]`, btnsRoot).forEach(b=>{
    b.classList.toggle("active", b.dataset.value===value);
  });
}

function getActiveRadio(btnsRoot, group){
  const b = qs(`.radioBtn[data-group="${group}"].active`, btnsRoot);
  return b ? b.dataset.value : "";
}

function buildPhaseButtons(curvaKey, rootEl, group){
  rootEl.innerHTML = "";
  if(!curvaKey) return;
  PHASES[curvaKey].forEach(p=>{
    const div = document.createElement("div");
    div.className = "radioBtn";
    div.dataset.group = group;
    div.dataset.value = p.key;
    div.textContent = p.label;
    rootEl.appendChild(div);
  });
}

function listSignals(curvaKey, faseKey, filterFn){
  return SIGNALS.filter(s=>{
    if(curvaKey && s.curva!==curvaKey) return false;
    if(faseKey && s.fase!==faseKey) return false;
    return filterFn ? filterFn(s) : true;
  });
}

function renderCheckboxList(target, signals, namespace){
  if(!signals.length){
    target.innerHTML = `<div class="note">Selecione curva e fase para exibir os sinais.</div>`;
    return;
  }
  const wrap = document.createElement("div");
  wrap.className = "choices";
  signals.forEach(s=>{
    const row = document.createElement("div");
    row.className = "choice";
    const id = `${namespace}_${s.id}`;
    row.innerHTML = `
      <input type="checkbox" id="${id}" data-sigid="${s.id}">
      <div>
        <label for="${id}">${s.label}</label>
      </div>
    `;
    wrap.appendChild(row);
  });
  target.innerHTML = "";
  target.appendChild(wrap);
}

function selectedSignalIds(root){
  return qsa('input[type="checkbox"][data-sigid]:checked', root).map(x=>x.dataset.sigid);
}

function uniq(arr){ return [...new Set(arr)]; }

function formatLimits(curvaKey, tipos){
  const parts = [];
  parts.push("Limites gerais:");
  parts.push(...LIMITES_GERAIS.map(x=>"• "+x));

  if(curvaKey && LIMITES_CURVA[curvaKey]){
    parts.push("");
    parts.push("Limites específicos da curva:");
    parts.push(...LIMITES_CURVA[curvaKey].map(x=>"• "+x));
  }

  const t = uniq((tipos||[]).filter(Boolean));
  if(t.length){
    parts.push("");
    parts.push("Limites por tipo de leitura:");
    t.forEach(k=>{
      const block = LIMITES_TIPO[k] || [];
      block.forEach(x=>parts.push("• "+x));
    });
  }
  return parts.join("\n");
}

function copyText(text){
  return navigator.clipboard.writeText(text);
}

/* =========================
   MOTOR (SIMPLIFICADO + ROBUSTO)
   - Essencial: 1 leitura principal
   - Avançado: leitura principal + alternativas (até 2), prioridade por fase
========================= */

function phasePriority(curvaKey, faseKey){
  // prioridade: final > expiração > inspiração > ciclo
  if(curvaKey==="fluxo"){
    if(faseKey==="final") return 1;
    if(faseKey==="expiracao") return 2;
    if(faseKey==="inspiracao") return 3;
    if(faseKey==="ciclo") return 4;
  }
  if(curvaKey==="volume"){
    if(faseKey==="final") return 1;
    if(faseKey==="plato") return 2;
    if(faseKey==="enchimento") return 3;
    if(faseKey==="ciclo") return 4;
  }
  if(curvaKey==="pressao"){
    if(faseKey==="expiracao") return 1;
    if(faseKey==="plato") return 2;
    if(faseKey==="inspiracao") return 3;
    if(faseKey==="ciclo") return 4;
  }
  return 99;
}

function buildReading(curvaKey, faseKey, sigIds, mode, regOpt){
  // mode: "ess" | "av"
  const sigObjs = sigIds.map(id=>SIGNALS.find(s=>s.id===id)).filter(Boolean);

  // Observação
  const curvaLabel = curvaKey==="pressao" ? "Pressão × Tempo" : curvaKey==="fluxo" ? "Fluxo × Tempo" : "Volume × Tempo";
  const faseLabel = (PHASES[curvaKey].find(p=>p.key===faseKey)?.label) || "(fase não selecionada)";
  const obsLines = [];
  obsLines.push(`${curvaLabel} — ${faseLabel}`);
  obsLines.push("Sinais:");
  sigObjs.forEach(s=>obsLines.push("• "+s.label));
  if(regOpt){
    obsLines.push(`Ciclo a ciclo: ${regOpt==="variavel" ? "Variável" : "Consistente"}`);
  }

  // Seleção de leitura principal (prioridade por fase; dentro da fase, pega o primeiro marcado)
  // (No Avançado, aceita sinais múltiplos e complementa com alternativas)
  let principal = null;

  // Se usuário marcou sinais de fases diferentes (possível na aba Av), prioriza pela regra do app.
  // Para isso, considera a fase do próprio sinal, não só faseKey.
  const sorted = [...sigObjs].sort((a,b)=>{
    const pa = phasePriority(curvaKey, a.fase);
    const pb = phasePriority(curvaKey, b.fase);
    return pa - pb;
  });
  principal = sorted[0] || null;

  const leituraLines = [];
  const tipos = [];

  if(!principal){
    return { ok:false, msg:"Selecione ao menos 1 sinal observável.", obs:"", read:"", limits:"" };
  }

  // Leitura principal
  leituraLines.push("Leitura principal:");
  leituraLines.push("• " + principal.leitura);
  if(principal.tipo) tipos.push(principal.tipo);

  // Avançado: até 2 alternativas
  if(mode==="av"){
    const alts = [];
    if(principal.alt && principal.alt.length){
      principal.alt.forEach(a=>alts.push(a));
    }
    // Se houver mais sinais relevantes (mesma prioridade), adiciona leituras deles como alternativas (até 2)
    for(const s of sorted.slice(1)){
      if(alts.length>=2) break;
      alts.push(s.leitura);
      if(s.tipo) tipos.push(s.tipo);
    }
    const altsTrim = alts.filter(Boolean).slice(0,2);
    if(altsTrim.length){
      leituraLines.push("");
      leituraLines.push("Leituras alternativas (quando aplicável):");
      altsTrim.forEach(x=>leituraLines.push("• " + x));
    }

    // Se regOpt variável, adiciona interpretação de estabilidade (sem conduta)
    if(regOpt==="variavel"){
      leituraLines.push("");
      leituraLines.push("Complemento (ciclo a ciclo):");
      leituraLines.push("• Variabilidade do padrão sugere instabilidade do comportamento mecânico ao longo do tempo.");
      tipos.push("estabilidade");
    }
  }

 const limits = (mode==="ess")
  ? LIMITE_ESSENCIAL
  : formatLimits(curvaKey, tipos);

  return {
    ok:true,
    obs: obsLines.join("\n"),
    read: leituraLines.join("\n"),
    limits
  };
}

/* =========================
   UI — ABAS
========================= */
qsa(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    qsa(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    const which = t.dataset.tab;
    qs("#tab_ess").classList.toggle("hidden", which!=="ess");
    qs("#tab_av").classList.toggle("hidden", which!=="av");
    qs("#tab_met").classList.toggle("hidden", which!=="met");
  });
});

/* =========================
   ESSENCIAL — UI BINDINGS
========================= */
const essCurveBtns = qs("#ess_curveBtns");
const essPhaseBtns = qs("#ess_phaseBtns");
const essSignalsWrap = qs("#ess_signalsWrap");
const essHint = qs("#ess_hint");

function essSetHint(text, kind="note"){
  essHint.classList.remove("hidden","danger");
  essHint.classList.add("note");
  if(kind==="danger") essHint.classList.add("danger");
  essHint.textContent = text;
}
function essClearHint(){ essHint.classList.add("hidden"); essHint.textContent=""; }

essCurveBtns.addEventListener("click", (e)=>{
  const btn = e.target.closest(".radioBtn");
  if(!btn) return;
  const curva = btn.dataset.value;
  setActiveRadio(essCurveBtns, "ess_curve", curva);

  // reset fase e sinais
  buildPhaseButtons(curva, essPhaseBtns, "ess_phase");
  setActiveRadio(essPhaseBtns, "ess_phase", ""); // none
  essSignalsWrap.innerHTML = `<div class="note">Selecione a fase para exibir os sinais essenciais.</div>`;
  essClearHint();
});

essPhaseBtns.addEventListener("click", (e)=>{
  const btn = e.target.closest(".radioBtn");
  if(!btn) return;
  const fase = btn.dataset.value;
  setActiveRadio(essPhaseBtns, "ess_phase", fase);

  const curva = getActiveRadio(essCurveBtns, "ess_curve");
  const sigs = listSignals(curva, fase, s=>ESSENTIAL_IDS.has(s.id));
  renderCheckboxList(essSignalsWrap, sigs, "ess");
  essClearHint();
});

qs("#btnEssLimpar").addEventListener("click", ()=>{
  qsa('.radioBtn[data-group="ess_curve"]', essCurveBtns).forEach(b=>b.classList.remove("active"));
  essPhaseBtns.innerHTML = "";
  essSignalsWrap.innerHTML = `<div class="note">Selecione uma curva para exibir os sinais.</div>`;
  qs("#ess_outBox").classList.add("hidden");
  qs("#ess_copyMsg").textContent = "";
  essClearHint();
});

qs("#btnEssGerar").addEventListener("click", ()=>{
  const curva = getActiveRadio(essCurveBtns, "ess_curve");
  const fase = getActiveRadio(essPhaseBtns, "ess_phase");
  if(!curva){ essSetHint("Selecione a curva.", "danger"); return; }
  if(!fase){ essSetHint("Selecione a fase.", "danger"); return; }

  const ids = selectedSignalIds(essSignalsWrap);
  if(ids.length<1){ essSetHint("Selecione ao menos 1 sinal observável.", "danger"); return; }

  if(ids.length>3){
    essSetHint("Você marcou mais de 3 sinais. Para múltiplos sinais, use a aba Avançado (aqui a leitura permanece simplificada).", "note");
  } else {
    essClearHint();
  }

  const r = buildReading(curva, fase, ids, "ess", "");
  if(!r.ok){ essSetHint(r.msg, "danger"); return; }

  qs("#ess_obs").textContent = r.obs;
  qs("#ess_read").textContent = r.read;
  qs("#ess_limits").textContent = r.limits;

  qs("#ess_outBox").classList.remove("hidden");
  qs("#ess_copyMsg").textContent = "";
});

qs("#btnEssCopiar").addEventListener("click", async ()=>{
  const text =
`Mecânica Respiratória — Curvas Ventilatórias (Educacional)

O que se observa
${qs("#ess_obs").textContent}

O que isso pode indicar
${qs("#ess_read").textContent}

Limites da interpretação
${qs("#ess_limits").textContent}`;
  try{
    await copyText(text);
    qs("#ess_copyMsg").textContent = "Copiado.";
  }catch(err){
    qs("#ess_copyMsg").textContent = "Não foi possível copiar automaticamente. Selecione e copie manualmente.";
  }
});

/* =========================
   AVANÇADO — UI BINDINGS
========================= */
const avCurveBtns = qs("#av_curveBtns");
const avPhaseBtns = qs("#av_phaseBtns");
const avSignalsWrap = qs("#av_signalsWrap");
const avRegBtns = qs("#av_regBtns");
const avHint = qs("#av_hint");

function avSetHint(text, kind="note"){
  avHint.classList.remove("hidden","danger");
  avHint.classList.add("note");
  if(kind==="danger") avHint.classList.add("danger");
  avHint.textContent = text;
}
function avClearHint(){ avHint.classList.add("hidden"); avHint.textContent=""; }

avCurveBtns.addEventListener("click", (e)=>{
  const btn = e.target.closest(".radioBtn");
  if(!btn) return;
  const curva = btn.dataset.value;
  setActiveRadio(avCurveBtns, "av_curve", curva);

  buildPhaseButtons(curva, avPhaseBtns, "av_phase");
  setActiveRadio(avPhaseBtns, "av_phase", "");
  avSignalsWrap.innerHTML = `<div class="note">Selecione a fase para exibir os sinais.</div>`;
  qsa('.radioBtn[data-group="av_reg"]', avRegBtns).forEach(b=>b.classList.remove("active"));
  avClearHint();

  qs("#av_outBox").classList.add("hidden");
  qs("#av_copyMsg").textContent = "";
});

avPhaseBtns.addEventListener("click", (e)=>{
  const btn = e.target.closest(".radioBtn");
  if(!btn) return;
  const fase = btn.dataset.value;
  setActiveRadio(avPhaseBtns, "av_phase", fase);

  const curva = getActiveRadio(avCurveBtns, "av_curve");

  // No Avançado, para permitir marcação ampla, mostramos sinais da fase selecionada
  // e também um bloco "ciclo a ciclo" quando curva/fase não é ciclo? Mantemos simples: só fase selecionada.
  const sigs = listSignals(curva, fase, null);
  renderCheckboxList(avSignalsWrap, sigs, "av");
  avClearHint();
});

avRegBtns.addEventListener("click", (e)=>{
  const btn = e.target.closest(".radioBtn");
  if(!btn) return;
  const value = btn.dataset.value;
  setActiveRadio(avRegBtns, "av_reg", value);
});

qs("#btnAvLimpar").addEventListener("click", ()=>{
  qsa('.radioBtn[data-group="av_curve"]', avCurveBtns).forEach(b=>b.classList.remove("active"));
  avPhaseBtns.innerHTML = "";
  avSignalsWrap.innerHTML = `<div class="note">Selecione uma curva para exibir os sinais.</div>`;
  qsa('.radioBtn[data-group="av_reg"]', avRegBtns).forEach(b=>b.classList.remove("active"));
  qs("#av_outBox").classList.add("hidden");
  qs("#av_copyMsg").textContent = "";
  avClearHint();
});

qs("#btnAvGerar").addEventListener("click", ()=>{
  const curva = getActiveRadio(avCurveBtns, "av_curve");
  const fase = getActiveRadio(avPhaseBtns, "av_phase");
  const reg  = getActiveRadio(avRegBtns, "av_reg"); // opcional

  if(!curva){ avSetHint("Selecione a curva.", "danger"); return; }
  if(!fase){ avSetHint("Selecione a fase.", "danger"); return; }

  const ids = selectedSignalIds(avSignalsWrap);
  if(ids.length<1){ avSetHint("Selecione ao menos 1 sinal observável.", "danger"); return; }

  avClearHint();

  const r = buildReading(curva, fase, ids, "av", reg);
  if(!r.ok){ avSetHint(r.msg, "danger"); return; }

  qs("#av_obs").textContent = r.obs;
  qs("#av_read").textContent = r.read;
  qs("#av_limits").textContent = r.limits;

  qs("#av_outBox").classList.remove("hidden");
  qs("#av_copyMsg").textContent = "";
});

qs("#btnAvCopiar").addEventListener("click", async ()=>{
  const text =
`Mecânica Respiratória — Curvas Ventilatórias (Educacional) — Avançado

O que se observa
${qs("#av_obs").textContent}

O que isso pode indicar
${qs("#av_read").textContent}

Limites da interpretação
${qs("#av_limits").textContent}`;
  try{
    await copyText(text);
    qs("#av_copyMsg").textContent = "Copiado.";
  }catch(err){
    qs("#av_copyMsg").textContent = "Não foi possível copiar automaticamente. Selecione e copie manualmente.";
  }
});

/* =========================
   MÉTODO — preencher limites gerais
========================= */
qs("#met_limitesGerais").innerHTML = "<ul>" + LIMITES_GERAIS.map(x=>`<li>${x}</li>`).join("") + "</ul>";
</script>
</body>
</html>
